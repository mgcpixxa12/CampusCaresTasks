<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Task Tracker Updated</title>
<style>
body { font-family: Arial, sans-serif; margin: 10px; }
h1 { text-align: center; }
#toolbar { display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; margin: 10px 0 15px; }
#toolbar .group { background:#f5f5f5; padding:8px; border-radius:8px; display:flex; gap:8px; align-items:center; }
#toolbar input[type="date"] { padding:3px; }
#toolbar button { padding:6px 10px; border:none; border-radius:6px; cursor:pointer; background:#4CAF50; color:#fff; }
#toolbar button.secondary { background:#607D8B; }
#toolbar button.danger { background:#d9534f; }

#topBar { display: flex; justify-content: space-between; gap: 20px; margin-bottom: 15px; }
#taskInputContainer { flex: 1; max-width: 50%; background: #f4f4f4; padding: 10px; border-radius: 5px; }
/* Top-right: Completed Log */
#logTopContainer { flex: 1; background: #eaeaea; padding: 5px; border-radius: 5px; overflow-y: auto; max-height: 120px; font-size: 12px; }
#logTopContainer h3 { margin: 0 0 6px 0; }

/* Bottom layout */
#taskContainer { display: flex; justify-content: space-between; gap: 20px; }
.column { background: #f9f9f9; padding: 10px; border-radius: 5px; min-height: 400px; }
#permanentTasks { flex: 1; }
#todaysTasks { flex: 1; }
#monitoredColumn { flex: 2; display: flex; flex-direction: column; }

/* Monitored blocks */
.monitored-columns { display: flex; gap: 10px; }
#fishTankCol { flex: 1.5; }
#turfCol { flex: 0.5; }
.monitored-header { display: flex; justify-content: space-between; align-items: center; font-weight: bold; margin-bottom: 5px; gap: 5px; }
.monitored-header input { flex: 1; font-size: 12px; padding: 2px; }
.monitored-row { background: #fff; border: 1px solid #ccc; padding: 3px; margin-bottom: 3px; display: flex; flex-wrap: wrap; align-items: center; gap: 6px; }
.monitored-name { font-size: 13px; font-weight: bold; margin-right: auto; }
.pill { display: inline-flex; align-items: center; padding: 2px 6px; border-radius: 4px; margin-right: 2px; font-size: 11px; cursor: pointer; user-select: none; }
.pill .label { font-size: 10px; margin-right: 6px; font-weight: 600; letter-spacing: .2px; }
.pill.noclick { cursor: default; }
.pill button { display: none; }

.category { background: #ddd; padding: 5px; margin-top: 5px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; gap: 8px; }
.category .right { display:flex; gap:6px; }
.subcategory { background: #eee; padding: 5px; margin-left: 15px; cursor: pointer; }
.task { background: white; padding: 5px; margin-left: 30px; display: flex; justify-content: space-between; align-items: center; gap:8px; }

/* Batch add */
.batchRow { display: flex; gap: 20px; margin-bottom: 10px; }
.batchCol { flex: 1; }
.batchItem { display: flex; gap: 5px; margin-bottom: 5px; }
.batchItem input { flex: 1; padding: 5px; }
.addRowBtn { padding: 0 10px; background: #4CAF50; color: white; border: none; cursor: pointer; }
.removeBtn { background: red; color: white; border: none; padding: 0 6px; cursor: pointer; }
button.deleteBtn { background: red; color: white; border: none; padding: 2px 5px; cursor: pointer; }
button.completeBtn { background: green; color: white; border: none; padding: 2px 5px; cursor: pointer; }

/* Completed Log list */
#logList { list-style: none; padding: 0; }
#logList li { background: white; padding: 5px; margin-bottom: 5px; display: flex; justify-content: space-between; }

.hidden { display:none; }
</style>
</head>
<body>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
  import { getFirestore, doc, getDoc, setDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyBM8-UblpxJMprW4S79gJtMaFSkG0SvEJY",
    authDomain: "campus-cares.firebaseapp.com",
    projectId: "campus-cares",
    storageBucket: "campus-cares.firebasestorage.app",
    messagingSenderId: "617226284452",
    appId: "1:617226284452:web:14f9d238e79ba6854aa531",
    measurementId: "G-78HSW48BCJ"
  };

  const app  = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db   = getFirestore(app);

  window.__firebase = {
    auth, db, GoogleAuthProvider, signInWithPopup, onAuthStateChanged, signOut,
    doc, getDoc, setDoc, serverTimestamp
  };
</script>

<h1>Task Tracker</h1>

<!-- Auth bar -->
<div id="authBar" style="display:flex; gap:8px; align-items:center; justify-content:center; margin:10px 0;">
  <span id="userInfo" style="font-weight:600;"></span>
  <button id="loginBtn" class="secondary">Sign in with Google</button>
  <button id="logoutBtn" class="danger" style="display:none;">Sign out</button>
  <span id="syncStatus" style="font-size:12px; opacity:.8;"></span>
</div>

<!-- Toolbar: Session + Print + Export/Import -->
<div id="toolbar">
  <div class="group">
    <strong>Location Session:</strong>
    <select id="sessionSelect" title="Choose location/session"></select>
    <button class="secondary" id="newSessionBtn">New</button>
    <button class="secondary" id="renameSessionBtn">Rename</button>
    <button class="danger"    id="deleteSessionBtn">Delete</button>
  </div>

  <div class="group">
    <strong>Print Completed Log by Date:</strong>
    <label>From <input type="date" id="printFrom"></label>
    <label>To <input type="date" id="printTo"></label>
    <button onclick="printLogByDate()">Print Filtered Log</button>
  </div>

  <div class="group">
    <strong>Session Data:</strong>
    <button class="secondary" onclick="exportSession()">Download (.json)</button>
    <input id="importFile" type="file" accept="application/json" class="hidden" onchange="importSession(this.files[0])">
    <button class="secondary" onclick="document.getElementById('importFile').click()">Load</button>
  </div>
</div>

<div id="topBar">
    <div id="taskInputContainer">
        <input type="text" id="batchCategory" placeholder="Category" list="categoryList" style="margin-bottom:10px; width: 100%;">
        <datalist id="categoryList"></datalist>
        <div class="batchRow">
            <div class="batchCol">
                <strong>Tasks</strong>
                <div id="tasksContainer">
                    <div class="batchItem">
                        <input type="text" class="taskName" placeholder="Task Name">
                        <button type="button" class="addRowBtn" onclick="addTaskRow()">+</button>
                    </div>
                </div>
            </div>
            <div class="batchCol">
                <strong>Subcategories (optional)</strong>
                <div id="subcatsContainer">
                    <div class="batchItem">
                        <input type="text" class="taskSubcategory" placeholder="Subcategory" list="subcategoryList">
                        <button type="button" class="addRowBtn" onclick="addSubcatRow()">+</button>
                    </div>
                </div>
            </div>
        </div>
        <datalist id="subcategoryList"></datalist>
        <button onclick="submitBatch()">Add Task(s)</button>
    </div>

    <!-- Top-right: Completed Log -->
    <div id="logTopContainer">
        <h3>Completed Log</h3>
        <ul id="logList"></ul>
    </div>
</div>

<div id="taskContainer">
    <div class="column" id="permanentTasks">
        <h2>Permanent Tasks</h2>
        <div id="permanentList"></div>
    </div>
    <div class="column" id="todaysTasks">
        <h2>Today's Tasks</h2>
        <div id="todaysList"></div>
    </div>

    <!-- Bottom-right: Monitored section -->
    <div class="column" id="monitoredColumn">
        <h2>Monitored</h2>
        <div class="monitored-columns">
            <div class="monitored-col" id="fishTankCol">
                <div class="monitored-header">
                    Fish Tanks
                    <input id="fishInput" type="text" placeholder="Location Name">
                    <button class="completeBtn" onclick="addMonitoredFromInput('Fish Tank')">+</button>
                </div>
                <div id="fishTankList"></div>
            </div>
            <div class="monitored-col" id="turfCol">
                <div class="monitored-header">
                    Turfs
                    <input id="turfInput" type="text" placeholder="Location Name">
                    <button class="completeBtn" onclick="addMonitoredFromInput('Turf')">+</button>
                </div>
                <div id="turfList"></div>
            </div>
        </div>
    </div>
</div>

<script>
// ===== Session-scoped data =====
let currentSessionId = localStorage.getItem("activeSessionId") || "Default";
let sessionList = JSON.parse(localStorage.getItem("sessionList")) || ["Default"];

let tasks = {};
let todaysTasks = {};
let log = [];
let monitoredTasks = [];
let expandedCategory = null, expandedSubcategory = null, expandedTodayCategory = null, expandedTodaySubcategory = null;

// ---- LocalStorage helpers (namespaced by session) ----
function lsKey(name, sid = currentSessionId) { return `${sid}::${name}`; }

// ---- Local modified stamp ----
function bumpLocalStamp() {
  localStorage.setItem(lsKey("localUpdatedAt"), String(Date.now()));
}

// Load everything from local for a session
function loadFromLocal(sessionId = currentSessionId) {
  tasks          = JSON.parse(localStorage.getItem(lsKey("tasks", sessionId))) || {};
  todaysTasks    = JSON.parse(localStorage.getItem(lsKey("todaysTasks", sessionId))) || {};
  log            = JSON.parse(localStorage.getItem(lsKey("log", sessionId))) || [];
  monitoredTasks = JSON.parse(localStorage.getItem(lsKey("monitoredTasks", sessionId))) || [];
}

// Save to local (and bump local stamp)
function saveData() {
  localStorage.setItem(lsKey("tasks"), JSON.stringify(tasks));
  localStorage.setItem(lsKey("todaysTasks"), JSON.stringify(todaysTasks));
  localStorage.setItem(lsKey("log"), JSON.stringify(log));
  localStorage.setItem(lsKey("monitoredTasks"), JSON.stringify(monitoredTasks));
  bumpLocalStamp();
}

// Strong persistence: write local immediately, then force a cloud write if signed in.
async function persistNow() {
  saveData();
  const fb = window.__firebase;
  if (fb?.auth?.currentUser) {
    try {
      await cloudSave(fb.auth.currentUser.uid, currentSessionId); // force, not debounced
    } catch (e) {
      console.error("Immediate cloud save failed:", e);
    }
  }
}

// ===== Utilities for dates =====
function toISO(d){ return new Date(d).toISOString(); }
function fmtDate(dateStr) {
    if (!dateStr) return "";
    let d = new Date(dateStr);
    if (isNaN(d)) return "";
    return String(d.getMonth()+1).padStart(2,'0')+"/"+String(d.getDate()).padStart(2,'0');
}
function fmtDateYear(dateStr) {
    if (!dateStr) return "";
    let d = new Date(dateStr);
    if (isNaN(d)) return "";
    return String(d.getMonth()+1).padStart(2,'0')+"/"+String(d.getDate()).padStart(2,'0')+"/"+String(d.getFullYear()).slice(-2);
}
function pillColor(dateStr) {
    if (!dateStr) return "#f0f0f0";
    let d = new Date(dateStr);
    if (isNaN(d)) return "#f0f0f0";
    let diff = Math.floor((new Date()-d)/(1000*60*60*24));
    if (diff === 0) return "#d4f8d4";
    if (diff <= 6) {
        let ratio = diff/6;
        let r = Math.round(212 + (248-212)*ratio);
        let g = Math.round(248 - (248-212)*ratio);
        return `rgb(${r},${g},212)`;
    }
    return "#f8d4d4";
}

// ===== Monitored (Fish Tanks & Turfs) =====
function addMonitoredFromInput(type) {
    let inputId = type === "Fish Tank" ? "fishInput" : "turfInput";
    let name = document.getElementById(inputId).value.trim();
    if (!name) return;
    let newTask = { id: Date.now(), name, type };
    if (type === "Fish Tank") {
        newTask.hasFish = false;
        newTask.fishDate = "";
        newTask.filterDate = "";
        newTask.waterDate = "";
        newTask.cleanDate = "";
        newTask.status = "Good";
    } else {
        newTask.cleanDate = "";
    }
    monitoredTasks.push(newTask);
    document.getElementById(inputId).value = "";
    renderMonitored();
    persistNow();
}

function renderMonitored() {
    let fishList = document.getElementById("fishTankList");
    let turfList = document.getElementById("turfList");
    fishList.innerHTML = "";
    turfList.innerHTML = "";
    let fishTanks = monitoredTasks.filter(m => m.type === "Fish Tank").sort((a,b)=>a.name.localeCompare(b.name));
    let turfs = monitoredTasks.filter(m => m.type === "Turf").sort((a,b)=>a.name.localeCompare(b.name));

    fishTanks.forEach(task => {
        let row = document.createElement("div");
        row.className = "monitored-row";
        row.innerHTML = `
            <span class="monitored-name"></span>
            üêü<input type="checkbox" ${task.hasFish?"checked":""} onchange="updateMonitored(${task.id},'hasFish',this.checked)">
            ${fishPillHTML(task.id)}
            ${pillHTML(task.id,'filterDate','Filter', true)}
            ${pillHTML(task.id,'waterDate','Water', true)}
            ${pillHTML(task.id,'cleanDate','Cleaned', true)}
            <select onchange="updateMonitored(${task.id},'status',this.value)">
                <option ${task.status==="Good"?"selected":""}>Good</option>
                <option ${task.status==="Needs Cleaning"?"selected":""}>Needs Cleaning</option>
                <option ${task.status==="Critical"?"selected":""}>Critical</option>
            </select>
            <button class="deleteBtn" onclick="deleteMonitored(${task.id})">X</button>
        `;
        row.querySelector(".monitored-name").textContent = task.name;
        fishList.appendChild(row);
    });

    turfs.forEach(task => {
        let row = document.createElement("div");
        row.className = "monitored-row";
        row.innerHTML = `
            <span class="monitored-name"></span>
            ${pillHTML(task.id,'cleanDate','Cleaned', true)}
            <button class="deleteBtn" onclick="deleteMonitored(${task.id})">X</button>
        `;
        row.querySelector(".monitored-name").textContent = task.name;
        turfList.appendChild(row);
    });
}

function pillHTML(id, field, label, clickable) {
    let task = monitoredTasks.find(m => m.id === id);
    let date = task[field];
    let display = fmtDate(date);
    let color = pillColor(date);
    let cls = clickable ? 'pill' : 'pill noclick';
    let handler = clickable ? `onclick=\"setToday(${id},'${field}')\"` : '';
    return `<span class="${cls}" style="background:${color}" ${handler}>
                <span class="label">${label}</span>
                <span class="monitored-date">${display}</span>
            </span>`;
}

function fishPillHTML(id) {
    let task = monitoredTasks.find(m => m.id === id);
    let date = task.fishDate;
    let display = fmtDateYear(date);
    let color = pillColor(date);
    return `<span class="pill noclick" style="background:${color}">
                <span class="label">Fish</span>
                <span class="monitored-date">${display}</span>
            </span>`;
}

function updateMonitored(id, field, value) {
    let t = monitoredTasks.find(m => m.id === id);
    if (!t) return;
    t[field] = value;

    if (field === 'hasFish') {
        let now = new Date();
        let mmddyy = `${String(now.getMonth()+1).padStart(2,'0')}/${String(now.getDate()).padStart(2,'0')}/${String(now.getFullYear()).toString().slice(-2)}`;
        if (value) {
            t.fishDate = now.toISOString();
            log.unshift({ date: now.toLocaleDateString(), ts: now.toISOString(), category: 'Fish Added', subcategory: '', task: `A fish was added to ${t.name} on ${mmddyy}` });
        } else {
            log.unshift({ date: now.toLocaleDateString(), ts: now.toISOString(), category: 'Fish Lost', subcategory: '', task: `A fish was lost in ${t.name} on ${mmddyy}` });
            t.fishDate = "";
        }
        renderLog();
    }

    persistNow();
    renderMonitored();
}

function setToday(id, field) {
    let t = monitoredTasks.find(m => m.id === id);
    if (t) { t[field] = new Date().toISOString(); persistNow(); renderMonitored(); }
}

function deleteMonitored(id) {
    monitoredTasks = monitoredTasks.filter(m => m.id !== id);
    persistNow();
    renderMonitored();
}

// ===== Task Tracker core =====
function updateDatalists() {
    const categoryList = document.getElementById("categoryList");
    categoryList.innerHTML = "";
    Object.keys(tasks).forEach(cat => {
        let option = document.createElement("option");
        option.value = cat;
        categoryList.appendChild(option);
    });
    const subcatList = document.getElementById("subcategoryList");
    subcatList.innerHTML = "";
    Object.keys(tasks).forEach(cat => {
        Object.keys(tasks[cat]).forEach(sub => {
            if (sub !== "_tasks") {
                let option = document.createElement("option");
                option.value = sub;
                subcatList.appendChild(option);
            }
        });
    });
}

function renderLists() {
    renderPermanentTasks();
    renderTodaysTasks();
    renderLog();
    updateDatalists();
    // NOTE: no saveData() here‚Äîmutators call persistNow()
}

/* ---------- Safe task row (no inline onclick with user text) ---------- */
function makeTaskRow(category, subcategory, task, isToday) {
  const row = document.createElement("div");
  row.className = "task";

  const label = document.createElement("span");
  label.textContent = task; // safe text
  row.appendChild(label);

  if (isToday) {
    const completeBtn = document.createElement("button");
    completeBtn.className = "completeBtn";
    completeBtn.textContent = "‚úî";
    completeBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      completeTask(category, subcategory || "", task, true);
    });
    row.appendChild(completeBtn);
  }

  const deleteBtn = document.createElement("button");
  deleteBtn.className = "deleteBtn";
  deleteBtn.textContent = "X";
  deleteBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    deleteTask(category, subcategory || "", task, isToday);
  });
  row.appendChild(deleteBtn);

  return row;
}

function renderPermanentTasks() {
    let container = document.getElementById("permanentList");
    container.innerHTML = "";
    Object.keys(tasks).forEach(category => {
        let catDiv = document.createElement("div");
        catDiv.className = "category";

        const left = document.createElement("span");
        left.textContent = category;

        const right = document.createElement("div");
        right.className = "right";

        const addBtn = document.createElement("button");
        addBtn.className = "completeBtn";
        addBtn.style.padding = "2px 5px";
        addBtn.textContent = "+";
        addBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          addCategoryToToday(category);
        });

        const delBtn = document.createElement("button");
        delBtn.className = "deleteBtn";
        delBtn.textContent = "X";
        delBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          deleteCategory(category);
        });

        right.appendChild(addBtn);
        right.appendChild(delBtn);

        catDiv.appendChild(left);
        catDiv.appendChild(right);

        catDiv.addEventListener("click", () => toggleCategory(container, category, tasks, false));
        container.appendChild(catDiv);

        if (expandedCategory === category) renderCategoryContent(container, category, tasks, false);
    });
}

function renderTodaysTasks() {
    let container = document.getElementById("todaysList");
    container.innerHTML = "";
    Object.keys(todaysTasks).forEach(category => {
        let catDiv = document.createElement("div");
        catDiv.className = "category";

        const left = document.createElement("span");
        left.textContent = category;

        const right = document.createElement("div");
        right.className = "right";

        const delBtn = document.createElement("button");
        delBtn.className = "deleteBtn";
        delBtn.textContent = "X";
        delBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          deleteTodayCategory(category);
        });

        right.appendChild(delBtn);

        catDiv.appendChild(left);
        catDiv.appendChild(right);

        catDiv.addEventListener("click", () => toggleCategory(container, category, todaysTasks, true));
        container.appendChild(catDiv);

        if (expandedTodayCategory === category) renderCategoryContent(container, category, todaysTasks, true);
    });
}

function renderCategoryContent(container, category, source, isToday) {
    let catData = source[category];
    let subContainer = document.createElement("div");

    if (catData._tasks) {
        catData._tasks.forEach(task => {
            subContainer.appendChild(makeTaskRow(category, "", task, isToday));
        });
    }

    Object.keys(catData).forEach(sub => {
        if (sub !== "_tasks") {
            let subWrapper = document.createElement("div");
            let subDiv = document.createElement("div");
            subDiv.className = "subcategory";
            subDiv.textContent = sub;
            subDiv.onclick = (e) => { e.stopPropagation(); toggleSubcategory(subWrapper, category, sub, source, isToday); };
            subWrapper.appendChild(subDiv);
            if ((!isToday && expandedSubcategory === sub && expandedCategory === category) || (isToday && expandedTodaySubcategory === sub && expandedTodayCategory === category)) {
                renderSubcategoryContent(subWrapper, category, sub, source, isToday);
            }
            subContainer.appendChild(subWrapper);
        }
    });
    container.appendChild(subContainer);
}

function renderSubcategoryContent(wrapper, category, sub, source, isToday) {
    let subData = source[category][sub];
    let taskList = document.createElement("div");
    subData.forEach(task => {
        taskList.appendChild(makeTaskRow(category, sub, task, isToday));
    });
    wrapper.appendChild(taskList);
}

function toggleCategory(container, category, source, isToday) {
    if (isToday) { expandedTodayCategory = expandedTodayCategory === category ? null : category; expandedTodaySubcategory = null; }
    else { expandedCategory = expandedCategory === category ? null : category; expandedSubcategory = null; }
    renderLists();
}

function toggleSubcategory(wrapper, category, sub, source, isToday) {
    if (isToday) expandedTodaySubcategory = expandedTodaySubcategory === sub ? null : sub;
    else expandedSubcategory = expandedSubcategory === sub ? null : sub;
    renderLists();
}

function addCategoryToToday(category) {
    if (!todaysTasks[category]) todaysTasks[category] = { _tasks: [] };
    if (tasks[category]._tasks) tasks[category]._tasks.forEach(t => { if (!todaysTasks[category]._tasks.includes(t)) todaysTasks[category]._tasks.push(t); });
    Object.keys(tasks[category]).forEach(sub => {
        if (sub !== "_tasks") {
            if (!todaysTasks[category][sub]) todaysTasks[category][sub] = [];
            tasks[category][sub].forEach(t => { if (!todaysTasks[category][sub].includes(t)) todaysTasks[category][sub].push(t); });
        }
    });
    persistNow().then(renderLists);
}

async function completeTask(category, subcategory, task, isToday) {
    const now = new Date();
    log.unshift({ date: now.toLocaleDateString(), ts: now.toISOString(), category, subcategory: subcategory || "", task });
    if (subcategory) {
        todaysTasks[category][subcategory] = todaysTasks[category][subcategory].filter(t => t !== task);
        if (!todaysTasks[category][subcategory].length) delete todaysTasks[category][subcategory];
    } else {
        todaysTasks[category]._tasks = todaysTasks[category]._tasks.filter(t => t !== task);
    }
    if (!todaysTasks[category]?._tasks?.length && Object.keys(todaysTasks[category] || {}).length === 1) delete todaysTasks[category];
    await persistNow();
    renderLists();
}

async function deleteTask(category, subcategory, task, isToday) {
    if (isToday) {
        if (subcategory) { 
            todaysTasks[category][subcategory] = todaysTasks[category][subcategory].filter(t => t !== task); 
            if (!todaysTasks[category][subcategory].length) delete todaysTasks[category][subcategory]; 
        } else { 
            todaysTasks[category]._tasks = todaysTasks[category]._tasks.filter(t => t !== task); 
        }
        if (!todaysTasks[category]?._tasks?.length && Object.keys(todaysTasks[category] || {}).length === 1) delete todaysTasks[category];
    } else {
        if (subcategory) { 
            tasks[category][subcategory] = tasks[category][subcategory].filter(t => t !== task); 
            if (!tasks[category][subcategory].length) delete tasks[category][subcategory]; 
        } else { 
            tasks[category]._tasks = tasks[category]._tasks.filter(t => t !== task); 
        }
        if (!tasks[category]?._tasks?.length && Object.keys(tasks[category] || {}).length === 1) delete tasks[category];
    }
    await persistNow();
    renderLists();
}

function renderLog() {
    let logList = document.getElementById("logList");
    if (!logList) return;
    logList.innerHTML = "";
    log.forEach((entry, i) => {
        let li = document.createElement("li");
        const left = document.createElement("span");
        left.textContent = `${entry.date} - ${entry.category}${entry.subcategory ? " > " + entry.subcategory : ""} : ${entry.task}`;
        const del = document.createElement("button");
        del.className = "deleteBtn";
        del.textContent = "X";
        del.addEventListener("click", () => deleteLog(i));
        li.appendChild(left);
        li.appendChild(del);
        logList.appendChild(li);
    });
}

async function deleteLog(index) { 
    log.splice(index, 1); 
    await persistNow();
    renderLists(); 
}

async function deleteCategory(category) { 
    if (confirm(`Delete category "${category}" and all its tasks?`)) { 
        delete tasks[category]; 
        if (todaysTasks[category]) delete todaysTasks[category]; 
        await persistNow();
        renderLists(); 
    } 
}

async function deleteTodayCategory(category) { 
    if (confirm(`Remove "${category}" from today's tasks?`)) { 
        delete todaysTasks[category]; 
        await persistNow();
        renderLists(); 
    } 
}

function addTaskRow() { 
    let c = document.getElementById("tasksContainer"); 
    let d = document.createElement("div"); 
    d.className = "batchItem"; 
    d.innerHTML = `<input type="text" class="taskName" placeholder="Task Name"> <button type="button" class="removeBtn" onclick="this.parentElement.remove()">‚ùå</button>`; 
    c.appendChild(d); 
}

function addSubcatRow() { 
    let c = document.getElementById("subcatsContainer"); 
    let d = document.createElement("div"); 
    d.className = "batchItem"; 
    d.innerHTML = `<input type="text" class="taskSubcategory" placeholder="Subcategory" list="subcategoryList"> <button type="button" class="removeBtn" onclick="this.parentElement.remove()">‚ùå</button>`; 
    c.appendChild(d); 
}

function submitBatch() {
    let category = document.getElementById("batchCategory").value.trim();
    if (!category) return alert("Category required");
    let taskInputs = [...document.querySelectorAll(".taskName")].map(i => i.value.trim()).filter(Boolean);
    let subcatInputs = [...document.querySelectorAll(".taskSubcategory")].map(i => i.value.trim()).filter(Boolean);
    if (!taskInputs.length) return alert("At least one task required");
    if (!tasks[category]) tasks[category] = { _tasks: [] };
    if (!subcatInputs.length) {
        taskInputs.forEach(task => { if (!tasks[category]._tasks.includes(task)) tasks[category]._tasks.push(task); });
    } else {
        subcatInputs.forEach(subcat => {
            if (!tasks[category][subcat]) tasks[category][subcat] = [];
            taskInputs.forEach(task => { if (!tasks[category][subcat].includes(task)) tasks[category][subcat].push(task); });
        });
    }
    document.getElementById("tasksContainer").innerHTML = `<div class="batchItem">
        <input type="text" class="taskName" placeholder="Task Name">
        <button type="button" class="addRowBtn" onclick="addTaskRow()">+</button>
    </div>`;
    document.getElementById("subcatsContainer").innerHTML = `<div class="batchItem">
        <input type="text" class="taskSubcategory" placeholder="Subcategory" list="subcategoryList">
        <button type="button" class="addRowBtn" onclick="addSubcatRow()">+</button>
    </div>`;
    persistNow().then(renderLists);
}

// ===== Export / Import / Print (current session only) =====
function exportSession(){
  const payload = { sessionId: currentSessionId, tasks, todaysTasks, log, monitoredTasks, exportedAt: new Date().toISOString(), version: 3 };
  const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
  const a = document.createElement('a');
  const ts = new Date();
  const y = ts.getFullYear();
  const m = String(ts.getMonth()+1).padStart(2,'0');
  const d = String(ts.getDate()).padStart(2,'0');
  a.href = URL.createObjectURL(blob);
  a.download = `task-tracker-${currentSessionId}-${y}-${m}-${d}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}

function importSession(file){
  if(!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const data = JSON.parse(reader.result);
      if(!confirm(`Replace current "${currentSessionId}" data with the loaded session file?`)) return;
      tasks          = data.tasks || {};
      todaysTasks    = data.todaysTasks || {};
      log            = data.log || [];
      monitoredTasks = data.monitoredTasks || [];
      persistNow().then(() => {
        renderLists();
        renderMonitored();
        alert('Session loaded into current location.');
      });
    } catch(e){
      alert('Failed to load: ' + e.message);
    }
  };
  reader.readAsText(file);
}

function printLogByDate(){
  const fromVal = document.getElementById('printFrom').value;
  const toVal = document.getElementById('printTo').value;
  const from = fromVal ? new Date(fromVal + 'T00:00:00') : null;
  const to = toVal ? new Date(toVal + 'T23:59:59') : null;

  const entries = log.map(e => ({
    ...e,
    _ts: e.ts ? new Date(e.ts) : (isNaN(new Date(e.date)) ? null : new Date(e.date))
  })).filter(e => e._ts);

  const filtered = entries.filter(e => {
    if(from && e._ts < from) return false;
    if(to && e._ts > to) return false;
    return true;
  });

  const win = window.open('', '_blank');
  const style = `body{font-family:Arial,sans-serif;margin:20px;} h2{margin:0 0 10px} table{border-collapse:collapse;width:100%;} th,td{border:1px solid #ccc;padding:6px;text-align:left;} th{background:#f5f5f5;}`;
  const rangeTxt = `${fromVal || '‚Äî'} to ${toVal || '‚Äî'} (Session: ${currentSessionId})`;
  const rows = filtered.map(e => `<tr><td>${e.date || ''}</td><td>${e.category || ''}</td><td>${e.subcategory || ''}</td><td>${e.task || ''}</td></tr>`).join('');
  win.document.write(`<!DOCTYPE html><html><head><title>Completed Log</title><style>${style}</style></head><body>`+
    `<h2>Completed Log ${rangeTxt}</h2>`+
    `<table><thead><tr><th>Date</th><th>Category</th><th>Subcategory</th><th>Task</th></tr></thead><tbody>${rows}</tbody></table>`+
    `</body></html>`);
  win.document.close();
  win.focus();
  win.print();
}

/* ==== CLOUD SYNC (Firebase) with multi-sessions ==== */
const fbInit = () => {
  const fb = window.__firebase;
  if (!fb) return;

  const { auth, db, GoogleAuthProvider, signInWithPopup, onAuthStateChanged, signOut, doc, getDoc, setDoc, serverTimestamp } = fb;
  const $login  = document.getElementById('loginBtn');
  const $logout = document.getElementById('logoutBtn');
  const $user   = document.getElementById('userInfo');
  const $sync   = document.getElementById('syncStatus');
  const $sel    = document.getElementById('sessionSelect');
  const $newBtn = document.getElementById('newSessionBtn');
  const $renBtn = document.getElementById('renameSessionBtn');
  const $delBtn = document.getElementById('deleteSessionBtn');

  let saveTimer = null;
  function markSync(msg) { if ($sync) $sync.textContent = msg; }

  async function loadMeta(uid) {
    const ref = doc(db, 'users', uid, 'meta', 'meta');
    const snap = await getDoc(ref);
    if (snap.exists()) {
      const data = snap.data();
      sessionList = Array.isArray(data.sessions) && data.sessions.length ? data.sessions : ["Default"];
      currentSessionId = data.active || currentSessionId || "Default";
    } else {
      sessionList = sessionList && sessionList.length ? sessionList : ["Default"];
      await setDoc(ref, { sessions: sessionList, active: currentSessionId, updatedAt: serverTimestamp() }, { merge: true });
    }
    renderSessionSelect();
    localStorage.setItem("sessionList", JSON.stringify(sessionList));
    localStorage.setItem("activeSessionId", currentSessionId);
  }

  async function saveMeta(uid) {
    const ref = doc(db, 'users', uid, 'meta', 'meta');
    await setDoc(ref, { sessions: sessionList, active: currentSessionId, updatedAt: serverTimestamp() }, { merge: true });
  }

  function renderSessionSelect() {
    $sel.innerHTML = "";
    sessionList.forEach(s => {
      const opt = document.createElement('option');
      opt.value = s;
      opt.textContent = s;
      if (s === currentSessionId) opt.selected = true;
      $sel.appendChild(opt);
    });
  }

  async function cloudLoad(uid, sessionId) {
    try {
      const ref = doc(db, 'users', uid, 'sessions', sessionId);
      const snap = await getDoc(ref);

      const localStamp = Number(localStorage.getItem(lsKey("localUpdatedAt"))) || 0;

      if (snap.exists()) {
        const data = snap.data();
        const cloudModified = (typeof data.lastModified === 'number')
          ? data.lastModified
          : (data.updatedAt && typeof data.updatedAt.toMillis === 'function') ? data.updatedAt.toMillis() : 0;

        // ---- FIX: prefer LOCAL when equal (>=) ----
        if (localStamp >= cloudModified) {
          await setDoc(ref, {
            tasks, todaysTasks, log, monitoredTasks,
            updatedAt: serverTimestamp(),
            lastModified: localStamp || Date.now(),
            version: 3
          }, { merge: true });
          saveData(); // ensure local mirrors include latest stamp
          renderLists();
          renderMonitored();
          markSync(`Kept local "${sessionId}" ‚Üí synced to cloud ‚úì`);
        } else {
          // Cloud is strictly newer ‚Üí adopt it
          tasks          = data.tasks          || {};
          todaysTasks    = data.todaysTasks    || {};
          log            = Array.isArray(data.log) ? data.log : (data.log || []);
          monitoredTasks = data.monitoredTasks || [];
          saveData();
          renderLists();
          renderMonitored();
          markSync(`Loaded "${sessionId}" from cloud ‚úì`);
        }
      } else {
        // No cloud yet ‚Üí create from local
        await setDoc(ref, {
          tasks, todaysTasks, log, monitoredTasks,
          updatedAt: serverTimestamp(),
          lastModified: Number(localStorage.getItem(lsKey("localUpdatedAt"))) || Date.now(),
          version: 3
        }, { merge: true });
        saveData();
        renderLists();
        renderMonitored();
        markSync(`Started new "${sessionId}" (synced local ‚Üí cloud)`);
      }
    } catch (e) {
      console.error(e);
      markSync('Cloud load failed (using local)');
      renderLists();
      renderMonitored();
    }
  }

  async function cloudSave(uid, sessionId) {
    try {
      const ref = doc(db, 'users', uid, 'sessions', sessionId);
      await setDoc(ref, {
        tasks, todaysTasks, log, monitoredTasks,
        updatedAt: serverTimestamp(),
        lastModified: Number(localStorage.getItem(lsKey("localUpdatedAt"))) || Date.now(),
        version: 3
      }, { merge: true });
      markSync(`Saved "${sessionId}" ‚úì`);
    } catch (e) {
      console.error(e);
      markSync('Save failed (will retry)');
    }
  }

  // expose cloudSave so persistNow() can call it
  window.cloudSave = cloudSave;

  function cloudSaveDebounced(uid) {
    if (!uid) return;
    markSync('Saving‚Ä¶');
    clearTimeout(saveTimer);
    // shorter debounce to reduce race windows
    saveTimer = setTimeout(() => cloudSave(uid, currentSessionId), 200);
  }

  // Patch saveData to also cloud-save current session (debounced) after local writes
  if (typeof window.saveData === 'function') {
    const _origSaveData = window.saveData;
    window.saveData = function() {
      _origSaveData();
      const user = auth.currentUser;
      if (user) cloudSaveDebounced(user.uid);
    };
  }

  // Flush on tab hide to avoid losing last edits
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'hidden' && auth.currentUser) {
      cloudSave(auth.currentUser.uid, currentSessionId);
    }
  });

  // Extra flush on page unload (best effort)
  window.addEventListener('beforeunload', () => {
    if (auth.currentUser) {
      try { cloudSave(auth.currentUser.uid, currentSessionId); } catch {}
    }
  });

  // Session actions
  $sel.addEventListener('change', async (e) => {
    const next = e.target.value;
    if (!next) return;
    currentSessionId = next;
    localStorage.setItem("activeSessionId", currentSessionId);
    renderSessionSelect();
    // load local immediately for snappy UI, then cloud
    loadFromLocal(currentSessionId);
    renderLists();
    renderMonitored();
    if (auth.currentUser) {
      await cloudLoad(auth.currentUser.uid, currentSessionId);
      await saveMeta(auth.currentUser.uid);
    }
  });

  $newBtn.addEventListener('click', async () => {
    let name = prompt("New session/location name:", "");
    if (!name) return;
    name = name.trim();
    if (!name) return;
    if (sessionList.includes(name)) { alert("That session already exists."); return; }
    sessionList.push(name);
    currentSessionId = name;
    // start blank
    tasks = {}; todaysTasks = {}; log = []; monitoredTasks = [];
    persistNow().then(() => {
      renderSessionSelect();
      renderLists();
      renderMonitored();
      localStorage.setItem("sessionList", JSON.stringify(sessionList));
      localStorage.setItem("activeSessionId", currentSessionId);
    });
    if (auth.currentUser) {
      await saveMeta(auth.currentUser.uid);
    }
  });

  $renBtn.addEventListener('click', async () => {
    const oldName = currentSessionId;
    const next = prompt(`Rename session "${oldName}" to:`, oldName);
    if (!next || next === oldName) return;
    const newName = next.trim();
    if (!newName) return;
    if (sessionList.includes(newName)) { alert("A session with that name already exists."); return; }

    // Move localStorage namespace
    const oldTasks          = localStorage.getItem(lsKey("tasks", oldName));
    const oldTodaysTasks    = localStorage.getItem(lsKey("todaysTasks", oldName));
    const oldLog            = localStorage.getItem(lsKey("log", oldName));
    const oldMonitoredTasks = localStorage.getItem(lsKey("monitoredTasks", oldName));
    if (oldTasks !== null) localStorage.setItem(`${newName}::tasks`, oldTasks);
    if (oldTodaysTasks !== null) localStorage.setItem(`${newName}::todaysTasks`, oldTodaysTasks);
    if (oldLog !== null) localStorage.setItem(`${newName}::log`, oldLog);
    if (oldMonitoredTasks !== null) localStorage.setItem(`${newName}::monitoredTasks`, oldMonitoredTasks);
    localStorage.removeItem(`${oldName}::tasks`);
    localStorage.removeItem(`${oldName}::todaysTasks`);
    localStorage.removeItem(`${oldName}::log`);
    localStorage.removeItem(`${oldName}::monitoredTasks`);

    // Update session list + active
    sessionList = sessionList.map(s => s === oldName ? newName : s);
    currentSessionId = newName;
    localStorage.setItem("sessionList", JSON.stringify(sessionList));
    localStorage.setItem("activeSessionId", currentSessionId);

    // Reload UI
    loadFromLocal(currentSessionId);
    renderSessionSelect();
    renderLists();
    renderMonitored();

    // Cloud: copy old doc to new doc (simple overwrite)
    if (auth.currentUser) {
      const uid = auth.currentUser.uid;
      const oldRef = doc(db, 'users', uid, 'sessions', oldName);
      const oldSnap = await getDoc(oldRef);
      if (oldSnap.exists()) {
        await setDoc(doc(db, 'users', uid, 'sessions', newName), oldSnap.data(), { merge: true });
      } else {
        await setDoc(doc(db, 'users', uid, 'sessions', newName), { tasks, todaysTasks, log, monitoredTasks, updatedAt: serverTimestamp(), lastModified: Number(localStorage.getItem(lsKey("localUpdatedAt"))) || Date.now(), version: 3 }, { merge: true });
      }
      await saveMeta(uid);
    }
  });

  $delBtn.addEventListener('click', async () => {
    if (sessionList.length <= 1) { alert("You must keep at least one session."); return; }
    if (!confirm(`Delete session "${currentSessionId}" locally? (Cloud copy will remain for safety.)`)) return;
    // remove local data
    localStorage.removeItem(lsKey("tasks"));
    localStorage.removeItem(lsKey("todaysTasks"));
    localStorage.removeItem(lsKey("log"));
    localStorage.removeItem(lsKey("monitoredTasks"));
    localStorage.removeItem(lsKey("localUpdatedAt"));
    // update list / active
    sessionList = sessionList.filter(s => s !== currentSessionId);
    currentSessionId = sessionList[0];
    localStorage.setItem("sessionList", JSON.stringify(sessionList));
    localStorage.setItem("activeSessionId", currentSessionId);
    renderSessionSelect();
    loadFromLocal(currentSessionId);
    renderLists();
    renderMonitored();
    if (auth.currentUser) await saveMeta(auth.currentUser.uid);
  });

  // Auth handling
  onAuthStateChanged(auth, async (user) => {
    window.__activeUid = user ? user.uid : null;
    if (user) {
      $user.textContent = `Signed in as ${user.displayName || user.email}`;
      $login.style.display  = 'none';
      $logout.style.display = 'inline-block';
      await loadMeta(user.uid);
      await cloudLoad(user.uid, currentSessionId);
      cloudSaveDebounced(user.uid);
    } else {
      $user.textContent = '';
      $login.style.display  = 'inline-block';
      $logout.style.display = 'none';
      markSync('Signed out (local only)');
      // fall back to local
      renderSessionSelect();
      loadFromLocal(currentSessionId);
      renderLists();
      renderMonitored();
    }
  });

  $login?.addEventListener('click', async () => {
    try {
      const provider = new GoogleAuthProvider();
      await signInWithPopup(auth, provider);
    } catch (e) { alert('Sign-in failed: ' + e.message); }
  });
  $logout?.addEventListener('click', async () => { await signOut(auth); });
};

// Initial boot
window.addEventListener('DOMContentLoaded', () => {
  // prepare session select UI before auth to show immediately
  const sel = document.getElementById('sessionSelect');
  sel.innerHTML = "";
  sessionList.forEach(s => {
    const opt = document.createElement('option');
    opt.value = s; opt.textContent = s;
    if (s === currentSessionId) opt.selected = true;
    sel.appendChild(opt);
  });

  // Load from local first for instant UI
  loadFromLocal(currentSessionId);
  renderLists();
  renderMonitored();

  // then wire Firebase
  fbInit();
});
</script>
</body>
</html>
